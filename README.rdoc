= enumerated_state

Implement state patterns for your enumerated_attributes

== Resources

Install

* sudo gem enumerated_state

Use

* require 'enumerated_state'

	
== Description

This gem falls under the ASPIUM family of gems -- (Another State Pattern Implementation
Using Mixology).  This ASPIUM adds state pattern support to enumerated attributes (see enumerated_attribute[http://github.com/jeffp/enumerated_attribute])
and allows multiple state variables per object, one for each enumerated attribute.

== Basic implementation

If you are using enumerated_attribute, you may have code looking something like

  class Tractor
    def direction
      case
      when tractor.gear_is_first? then 'forwards'
      when tractor.gear_is_reverse? then 'backwards'
      else
        'stopped'
      end
    end
  end

Enumerated State lets you clean it up as so

  class Tractor
    enum_attr :gear, %w(reverse ^neutral first)
    acts_as_enumerated_state :gear

    def direction; nil; end  # called if gear == nil

    module Reverse
      def direction; 'backwards'; end
    end
    module Neutral
      def direction; 'stopped'; end
    end
    module First
      def direction; 'forwards'; end
    end
  end

== Multi-variable state and enum value conflicts

Use the :module option to avoid naming conflicts between enumerated attributes

  class Foobar
    enum_attr :alpha, %w(state1 state2)
    enum_attr :beta, %w(state1 state2 state3)  # names will overlap when mapped to modules

    acts_as_enumerated_state :alpha
    acts_as_enumerated_state :beta, :module=>'Beta'

    module State1 ... end
    module State2 ... end

    module Beta
      module State1 ... end
      module State2 ... end
      module State3 ... end
    end
  end

== Dependencies

* meta_programming
* mixology
* enumerated_attribute
