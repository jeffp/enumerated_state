= enumerated_state

Implement state patterns for your enumerated_attributes

== Resources

Install

* sudo gem enumerated_state

Use

* require 'enumerated_state'

	
== Description

This gem belongs to the ASPIUM family of gems -- (Another State Pattern Implementation
Using Mixology).  This ASPIUM adds state pattern support to enumerated attributes (see enumerated_attribute[http://github.com/jeffp/enumerated_attribute])
and allows multiple state variables per object, one for each enumerated attribute.

== Usage

=== Basic implementation

If you are using enumerated_attribute, you may have code looking something like

  class Tractor
    def direction
      case
      when tractor.gear_is_first? then 'forwards'
      when tractor.gear_is_reverse? then 'backwards'
      else
        'stopped'
      end
    end
  end

We can refactor and clean up this code a little with acts_as_enumerated_state like this

  class Tractor
    enum_attr :gear, %w(reverse ^neutral first)
    acts_as_enumerated_state :gear

    def direction; nil; end  # called if gear == nil

    module Reverse
      def direction; 'backwards'; end
    end
    module Neutral
      def direction; 'stopped'; end
    end
    module First
      def direction; 'forwards'; end
    end
  end

=== Multi-variable state and enum value conflicts

Use the :module option to avoid naming conflicts between enumerated attributes

  class Foobar
    enum_attr :alpha, %w(state1 state2)
    enum_attr :beta, %w(state1 state2 state3)  # names will collide when mapped to modules

    acts_as_enumerated_state :alpha
    acts_as_enumerated_state :beta, :module=>'Beta'

    module State1 ... end
    module State2 ... end

    module Beta
      module State1 ... end
      module State2 ... end
      module State3 ... end
    end
  end

=== Strict versus non-strict

The default declaration of acts_as_enumerated_state strictly requires a module for
each enum value.  Something like this will raise an error

  class Tractor
    enum_attr :gear, %w(reverse neutral first)
    acts_as_enumerated_state :gear

    module Reverse ...  end
    # where's the module for :neutral?
    module First ... end
  end

  Tractor.new.gear = :neutral  #raises an error

But you may want some of the enum values to use the methods defined on the object
itself, and this can be done by setting the :strict option to false like this

  class Tractor
    enum_attr :gear, %w(reverse neutral first)
    acts_as_enumerated_state :gear, :strict=>false

    def motion; 'stopped'; end

    module Reverse
      def motion; 'backwards'; end
    end
    module First
      def motion; 'forwards'; end
    end
  end

  t = Tractor.new
  t.gear = :neutral
  t.motion   # prints 'stopped'


== Dependencies

* meta_programming
* mixology
* enumerated_attribute
